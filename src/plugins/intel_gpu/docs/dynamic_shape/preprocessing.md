# Preprocessing for dynamic shape execution
As explained in basic flow of primitive execution for dynamic shape from [Overall flow](overall_flow.md), several preprocessing processes are performed before setting arguments to kernel and executing selected impl.

* update_shape - when the input shape changes, calculate and change the output shape and peform shape inference so that the shape is propagated to the next node.
* update_impl - depending on the changed shape, `primitive_impl` is retrieved from in-memory cache or new impl is selected.
* realloc_if_needed - allocates new output memory if necessary.

The following is a description for some of the representative preprocessing processes for dynamic shape execution.

## primitive_inst::update_shape
### Dynamic shape inference
To support dynamic shape in GPU plugin, `cldnn::layout` uses `ov::PartialShape` to express shape. While the exisiting `cldnn::tensor` does not support dynamic shape and has limitations in rank, `ov::PartialShape` supports static and dynamic dimensions and has no limitations in rank. And when creating `cldnn::primitive` from `ov::op`, `ov::PartialShape` that `ov::op` already has is directly used.

> **Note**: In the execution flow for the existing statis shape in GPU plugin, the shape of `ov::op` may be transformed into `ov::tensor` and used, so when creating `cldnn::primitive` from `ov::op`, It is seperated form execution flow for dynamic shape. When building  `cldnn::program`, if there is at least one dynamic node among the nodes, `ov::intel_gpu::allow_new_shape_infer` property is set [(link)](https://github.com/openvinotoolkit/openvino/blob/eea49f3c9e6bba5463460fdc126c2df38a4a5215/src/plugins/intel_gpu/src/plugin/program_builder.cpp#L139) and execution of static shape and dynamic shape is seperated through this property during `cldnn::primitive` creation. It will be integrated in the future when GPU plugin fully supports dynamic shape.

When the input shape of the model changes, the input shape of the current primitive is also updated by checking whether the input shape has changed, and the output shape is calculated through the input shape, then this shape is propaged to the next primitive on shape inference stage. 
Details on how to execute shape inference through `primitive::update_shape` when executing primitive in GPU plugin for dynamic shape are as follows:

1. In the basic flow that executes primitive, there is a runtime optimization stage (i.e. `primitive_inst::do_runtime_in_place_concat` [(link)](https://github.com/openvinotoolkit/openvino/blob/eea49f3c9e6bba5463460fdc126c2df38a4a5215/src/plugins/intel_gpu/src/graph/primitive_inst.cpp#L720)) that runs before `update_shape()`. At this time, if `update_shape()` has already been executed by another primitive, set `update_shape_done_by_other` to TRUE. Therefore, if `update_shape_done_by_other` is TRUE, `update_shape()` is skipped. [(link)](https://github.com/openvinotoolkit/openvino/blob/eea49f3c9e6bba5463460fdc126c2df38a4a5215/src/plugins/intel_gpu/src/graph/primitive_inst.cpp#L247)
2. First, output layouts of `kernel_impl_params` from the dependencies of `primitive_inst` are compared with the input layouts of `kernel_impl_params` of the current primitive. If changed, the changed shape is updated to input layouts of `kernel_impl_params`. [(link)](https://github.com/openvinotoolkit/openvino/blob/eea49f3c9e6bba5463460fdc126c2df38a4a5215/src/plugins/intel_gpu/src/graph/primitive_inst.cpp#L254)
3. Set `_shape_changed` to TRUE if the input shape has changed. [(link)](https://github.com/openvinotoolkit/openvino/blob/eea49f3c9e6bba5463460fdc126c2df38a4a5215/src/plugins/intel_gpu/src/graph/primitive_inst.cpp#L266)
4. If the current node is `shape_of` and the input shape has not changed, reset `_shape_changed` to FALSE and skip `update_shape()` [(link)](https://github.com/openvinotoolkit/openvino/blob/eea49f3c9e6bba5463460fdc126c2df38a4a5215/src/plugins/intel_gpu/src/graph/primitive_inst.cpp#L270)
5. If the current node is *`shape_of` subgraph*, check *dependent `shape_of` primitives* and skip `update_shape()` if the shape has not changed. [(link)](https://github.com/openvinotoolkit/openvino/blob/eea49f3c9e6bba5463460fdc126c2df38a4a5215/src/plugins/intel_gpu/src/graph/primitive_inst.cpp#L276)
6. If the input shape has not changed, the node generates dynamic output (e.g. `Nonzero`, `Unique`), or the output layouts of `kernel_impl_params` are already static, `update_shape()` is skipped. [(link)](https://github.com/openvinotoolkit/openvino/blob/eea49f3c9e6bba5463460fdc126c2df38a4a5215/src/plugins/intel_gpu/src/graph/primitive_inst.cpp#L313)
7. In static shape execution, data for additional inputs that determine the output shape are set as attributes when creating `cldnn:primitive`, but in dynamic shape execution, if data is stored in the output memory of the previous node, it will wait until these depedent nodes are executed. Therefore, in oreder to get the index for these memory dependent input nodes, most promgram_nodes define `get_shape_infer_dependencies()`. Then, it takes the information (i.e. index and memory for dependent input nodes) from the current node, stores it in `map`, and adds the relevant primitive event to the event list, and then waits until the relevant events are completed. At the end, save the update map in memory_deps of `kenel_impl_params`. [(link)](https://github.com/openvinotoolkit/openvino/blob/eea49f3c9e6bba5463460fdc126c2df38a4a5215/src/plugins/intel_gpu/src/graph/primitive_inst.cpp#L319)
8. Currently, it is divided into two APIs: `program_node`'s `calc_output_layout()` for calculating the output shape in static shape execution and `calc_output_layouts()` for dynamic shape execution. In this step, `calc_output_layouts()` is called to calculate the output shape trough the `shape_infer()` API of `ov::op` with updated input layouts of `kernel_impl_params`, primitive's attributes, and memory_deps and return output layouts as vector. Then update the newly calculated output layout to `output_layouts` in `kernel_impl_params` [(link)](https://github.com/openvinotoolkit/openvino/blob/eea49f3c9e6bba5463460fdc126c2df38a4a5215/src/plugins/intel_gpu/src/graph/primitive_inst.cpp#L366)
    ```cpp
    struct program_node {
        ...
    public:
        layout calc_output_layout() const;
        std::vector<layout> calc_output_layouts() const;
    }
    ```
9. If there is fused operation in `kernel_impl_params`, the output layout of the descriptor is also updated with `ov::PartialShape` of updated output layout. [(link)](https://github.com/openvinotoolkit/openvino/blob/eea49f3c9e6bba5463460fdc126c2df38a4a5215/src/plugins/intel_gpu/src/graph/primitive_inst.cpp#L379)

## primitive_inst::update_weight
If `primitive_impl` is created or updated through `update_impl()`, and it is a weightable node (e.g. `convolution`, `deconvolution`, `fc`), the weight should be reorderded to the layout required by kernel as needed. The following describes the processes performed in `update_weights()`.

1. If impl is nullptr or the current node is not weightable node, `update_weight()` is skipped. [(link)](https://github.com/openvinotoolkit/openvino/blob/eea49f3c9e6bba5463460fdc126c2df38a4a5215/src/plugins/intel_gpu/src/graph/primitive_inst.cpp#L1168)
2. Create *reorder kernel params* (i.e. `kernel_impl_params` for weights reorder) from `WeightsReorderParams` of `primitive_inst`. [(link)](https://github.com/openvinotoolkit/openvino/blob/eea49f3c9e6bba5463460fdc126c2df38a4a5215/src/plugins/intel_gpu/src/graph/primitive_inst.cpp#L1172)
3. In cases where weights reorder is not necessary, if weights were previously reordered, incorrect memory buffer is allocated, so reset *reordered weights cache* to original weight memory layout. [(link)](https://github.com/openvinotoolkit/openvino/blob/eea49f3c9e6bba5463460fdc126c2df38a4a5215/src/plugins/intel_gpu/src/graph/primitive_inst.cpp#L1181)
4. If weights reorder is necessary, update weight layout of `kernel_impl_params` to output layout of *reorder kernel params*. This is expected layout. [(link)](https://github.com/openvinotoolkit/openvino/blob/eea49f3c9e6bba5463460fdc126c2df38a4a5215/src/plugins/intel_gpu/src/graph/primitive_inst.cpp#L1186)
    - If the expected layout hits *reordered weights cache*, it is reused.
    - If the expected layout is compatible with the original layout, the orginal weights memory is reinterpered and added to *reordered weights cache* without the need for reordering.
    - If the expected layout miss *reordered weights cache*, retrieve cached reorder impl from `implementations cache` with `reorder kernel params`, or create a new reorder impl through `WeightsReordersFactory` and set compiled kernel to this reorder impl. And add it to `implementation cache`. Check whether the weights memory can be resued in `reordered weights cache`, reuse weights memory or allocate a new one. and then update `reordered weights cache`. Lastly use `kernel_arguments_data()` to set kernel arguments in reorder impl and execute kernel.

## primitive_inst::realloc_if_needed
In the case of static shape execution, output memory is allocated when creating `primitive_inst`, but in dynamic shape execution, output memory is allocated before arguments are set to kernel and execution. The following describes the processes performed in `realloc_if_needed()`.

1. If the current node is `concat` and has 1 user, `can_be_optimized()` is TRUE but `allocation_done_by_other` is FALSE (i.e. not yet allocated by another node), execute `concat`'s `realloc_if_needed()` and set `allocation_done_by_other` to TRUE. Also, use concant's output memory as the output memory of the current node and skip `realloc_if_needed()`. [(link)](https://github.com/openvinotoolkit/openvino/blob/eea49f3c9e6bba5463460fdc126c2df38a4a5215/src/plugins/intel_gpu/src/graph/primitive_inst.cpp#L390)
2. For better performance, if *fake aligned shape* is used when executing kernel (e.g. `fully_connected`), update the input and output shapes of `kernel impl params`. A more detailed explanation of this will be added as a seperate section later(TBD). [(link)](https://github.com/openvinotoolkit/openvino/blob/eea49f3c9e6bba5463460fdc126c2df38a4a5215/src/plugins/intel_gpu/src/graph/primitive_inst.cpp#L403)
3. If the node is `input_layout`, `realloc_if_needed()` is skipped because it is assumed to always use external memory. [(link)](https://github.com/openvinotoolkit/openvino/blob/eea49f3c9e6bba5463460fdc126c2df38a4a5215/src/plugins/intel_gpu/src/graph/primitive_inst.cpp#L408)
4. Check whether output memory is already allocated and the requested buffer size is smaller than the current buffer size, and store the result in `can_reuse_buffer`. [(link)](https://github.com/openvinotoolkit/openvino/blob/eea49f3c9e6bba5463460fdc126c2df38a4a5215/src/plugins/intel_gpu/src/graph/primitive_inst.cpp#L421)
5. If the current node is `concat` and both `can_be_optimized()` and `allocation_done_by_other` are TRUE, `realloc_if_needed()` is skipped. [(link)](https://github.com/openvinotoolkit/openvino/blob/eea49f3c9e6bba5463460fdc126c2df38a4a5215/src/plugins/intel_gpu/src/graph/primitive_inst.cpp#L424)
6. Through `ShapePredictor`, the preallocation shape is predicted from the current shape and data type, and then update to output layout shape of `kernel impl params`. [(link)](https://github.com/openvinotoolkit/openvino/blob/eea49f3c9e6bba5463460fdc126c2df38a4a5215/src/plugins/intel_gpu/src/graph/primitive_inst.cpp#L429) More detail on the `ShapePredictor` can be found [here](memory_preallocation.md).
7. If `can_reuse_buffer` is TRUE, `reused` of output memory is set to TRUE and output memory is updated with reinterpreted buffer. [(link)](https://github.com/openvinotoolkit/openvino/blob/eea49f3c9e6bba5463460fdc126c2df38a4a5215/src/plugins/intel_gpu/src/graph/primitive_inst.cpp#L439)
8. If `can_reuse_buffer` is FALSE, reallocate with `allocate_outputs()` to set the output memory and update `max_output_layout_size`. [(link)](https://github.com/openvinotoolkit/openvino/blob/eea49f3c9e6bba5463460fdc126c2df38a4a5215/src/plugins/intel_gpu/src/graph/primitive_inst.cpp#L448)
9. Get internal buffer layouts from the current `primitive_impl`. [(link)](https://github.com/openvinotoolkit/openvino/blob/eea49f3c9e6bba5463460fdc126c2df38a4a5215/src/plugins/intel_gpu/src/graph/primitive_inst.cpp#L458)
    - If the previsouly allocated intermediate memory can be reused, the intermediate memory is updated with reinterpreted buffer.
    - If it cannot be resued, allocate a new buffer through `allocate_internal_buffer()` to update or add a new intermedidate memory that has already been allocated.
