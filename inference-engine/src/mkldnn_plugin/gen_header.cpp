// Copyright (C) 2018-2020 Intel Corporation
// SPDX-License-Identifier: Apache-2.0
//

#include <string>
#include <iostream>
#include <fstream>
#include <cstdlib>
#include <vector>
#include <algorithm>

#include <ngraph/function.hpp>

#include <file_utils.h>
#include <xml_parse_utils.h>
#include <ie_core.hpp>

namespace {

std::string baseName(std::string const & path) {
    return path.substr(path.find_last_of("/\\") + 1);
}

std::string withoutExtension(std::string const & path) {
    return path.substr(0, path.find_last_of("."));
}

std::string generateExecGraph(InferenceEngine::Core & ie, const char * graph,
                              const char * deviceName, const char * suffix) {
    IE_ASSERT(FileUtils::fileExist(graph));
    std::string execGraphName = "exec_" + withoutExtension(baseName(graph)) + suffix + ".xml";
    auto network = ie.ReadNetwork(graph);
    auto execNetwork = ie.LoadNetwork(network, deviceName);
    auto execGraph = execNetwork.GetExecGraphInfo();
    execGraph.serialize(execGraphName);
    return execGraphName;
}

void processGraph(InferenceEngine::Core & ie, const char * graph, std::ostream & header) {
    // generate execution graph and serialize
    std::string execGraphName = generateExecGraph(ie, graph, "cpu_reference", "_ref");

    IE_ASSERT(FileUtils::fileExist(execGraphName));
    auto parse_result = ParseXml(execGraphName.c_str());
    if (!parse_result.error_msg.empty()) {
        throw std::logic_error(parse_result.error_msg);
    }
    auto xmlDoc = std::move(parse_result.xml);
    pugi::xml_node root = xmlDoc->document_element();

    header << "//\n";
    header << "// Macro definitions for " << XMLParseUtils::GetStrAttr(root, "name", "") << std::endl;
    header << "//\n\n";

    auto printDefinitions = [&](const std::string & layer,
                                const std::vector<std::string> & defines) {
        header << "// " << layer << std::endl;
        for (auto && define : defines) {
            header << "#ifndef " << define << std::endl;
            header << "#define " << define << " 1" << std::endl;
            header << "#endif" << std::endl;
        }
        header << std::endl;
    };

    auto network = ie.ReadNetwork(graph);
    for (auto node = root.child("layers").child("layer"); !node.empty();
              node = node.next_sibling("layer")) {
        std::string layerName = XMLParseUtils::GetStrAttr(node, "id") + ":" +
                                XMLParseUtils::GetStrAttr(node, "name");
        std::string type = "Gen_" + XMLParseUtils::GetStrAttr(node, "type");

        auto dataNode = node.child("data");
        std::string primitiveType = XMLParseUtils::GetStrAttr(dataNode, "primitiveType");

        printDefinitions(layerName, {
            type,
            type + "_" + primitiveType
        });

        // print original layer names types
        std::string originalLayersNames = XMLParseUtils::GetStrAttr(dataNode, "originalLayersNames");
        for (auto & c : originalLayersNames) {
            if (c == ',')
                c = ' ';
        }

        std::istringstream iss(originalLayersNames);
        std::vector<std::string> definitions;
        std::transform(std::istream_iterator<std::string>{iss}, std::istream_iterator<std::string>(),
                       std::back_inserter(definitions), [&network] (const std::string & lName) {
                           auto maskLayerName = [](const std::string & str) { return "Gen_" + str; };

                           if (auto function = network.getFunction()) {
                               for (const auto & op : function->get_ops()) {
                                   if (op->get_friendly_name() == lName)
                                       return maskLayerName(op->get_type_name());
                               }

                               IE_ASSERT(false);
                           } else {
                               IE_SUPPRESS_DEPRECATED_START
                               return maskLayerName(network.getLayerByName(lName.c_str())->type);
                               IE_SUPPRESS_DEPRECATED_END
                           }
                       });
        printDefinitions(layerName + " + originalLayersNames", definitions);
    }
}

void generateHeader(InferenceEngine::Core & ie,
                    const std::vector<char *> & graphs,
                    std::ostream & header) {
    // generate common macro
    header << "// autogenerated: do not touch\n\n";
    header << "#ifdef GraphGen\n";
    header << "#error \"GraphGen already defined\"\n";
    header << "#else\n";
    header << "#define GraphGen(impl) impl\n";
    header << "#endif \n\n";

    for (size_t i = 0; i < graphs.size(); ++i) {
        processGraph(ie, graphs[i], header);
    }
}

}  // namespace

int main(int argc, char *argv[]) {
    try {
        InferenceEngine::Core ie;

        if (argc == 2) {
            // just to generate execution graph
            generateExecGraph(ie, argv[1], "CPU", "_actual");
        } else {
            ie.RegisterPlugin(argv[1], "cpu_reference");

            std::ofstream header(argv[2]);
            if (!header.is_open()) {
                throw std::logic_error("Failed to open header file");
            }

            generateHeader(ie, std::vector<char *>(argv + 3, argv + argc), header);
        }
    } catch (const std::exception & ex) {
        std::cerr << ex.what() << std::endl;
        return EXIT_FAILURE;
    }

    return EXIT_SUCCESS;
}
