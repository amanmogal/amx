// Copyright (C) 2018-2020 Intel Corporation
// SPDX-License-Identifier: Apache-2.0
//

#include <string>
#include <iostream>
#include <fstream>
#include <cstdlib>
#include <vector>
#include <algorithm>

#include <ngraph/function.hpp>

#include <file_utils.h>
#include <xml_parse_utils.h>
#include <ie_core.hpp>

namespace {

void processGraph(const char * execGraph, const char * graph, std::ostream & header) {
    auto parse_result = ParseXml(execGraph);
    if (!parse_result.error_msg.empty()) {
        throw std::logic_error(parse_result.error_msg);
    }
    auto xmlDoc = std::move(parse_result.xml);
    pugi::xml_node root = xmlDoc->document_element();

    header << "//\n";
    header << "// Macro definitions for " << XMLParseUtils::GetStrAttr(root, "name", "") << std::endl;
    header << "//\n\n";

    auto printDefinitions = [&](const std::string & layer,
                                const std::vector<std::string> & defines) {
        header << "// " << layer << std::endl;
        for (auto && define : defines) {
            header << "#ifndef " << define << std::endl;
            header << "#define " << define << " 1" << std::endl;
            header << "#endif" << std::endl;
        }
        header << std::endl;
    };

    InferenceEngine::Core reader;
    auto network = reader.ReadNetwork(graph);

    for (auto node = root.child("layers").child("layer"); !node.empty();
              node = node.next_sibling("layer")) {
        std::string layerName = XMLParseUtils::GetStrAttr(node, "id") + ":" +
                                XMLParseUtils::GetStrAttr(node, "name");
        std::string type = "Gen_" + XMLParseUtils::GetStrAttr(node, "type");

        auto dataNode = node.child("data");
        std::string primitiveType = XMLParseUtils::GetStrAttr(dataNode, "primitiveType");

        printDefinitions(layerName, {
            type,
            type + "_" + primitiveType
        });

        // print original layer names types
        std::string originalLayersNames = XMLParseUtils::GetStrAttr(dataNode, "originalLayersNames");
        for (auto & c : originalLayersNames) {
            if (c == ',')
                c = ' ';
        }

        std::istringstream iss(originalLayersNames);
        std::vector<std::string> definitions;
        std::transform(std::istream_iterator<std::string>{iss}, std::istream_iterator<std::string>(),
                       std::back_inserter(definitions), [&network] (const std::string & lName) {
                           auto maskLayerName = [](const std::string & str) { return "Gen_" + str; };

                           if (auto function = network.getFunction()) {
                               for (const auto & op : function->get_ops()) {
                                   if (op->get_friendly_name() == lName)
                                       return maskLayerName(op->get_type_name());
                               }

                               IE_ASSERT(false);
                           } else {
                               IE_SUPPRESS_DEPRECATED_START
                               return maskLayerName(network.getLayerByName(lName.c_str())->type);
                               IE_SUPPRESS_DEPRECATED_END
                           }
                       });
        printDefinitions(layerName + " + originalLayersNames", definitions);
    }
}

void generateHeader(const std::vector<char *> & execGraphs,
                    const std::vector<char *> & graphs,
                    std::ostream & header) {
    // generate common macro
    header << "// autogenerated: do not touch\n\n";
    header << "#ifdef GraphGen\n";
    header << "#error \"GraphGen already defined\"\n";
    header << "#else\n";
    header << "#define GraphGen(impl) impl\n";
    header << "#endif \n\n";

    IE_ASSERT(execGraphs.size() == graphs.size());
    for (size_t i = 0; i < graphs.size(); ++i) {
        processGraph(execGraphs[i], graphs[i], header);
    }
}

}  // namespace

int main(int argc, char *argv[]) {
    try {
        std::string lastArg = argv[argc - 1];
        bool genHeaderMode = FileUtils::fileExt(lastArg) == "hpp";

        if (genHeaderMode) {
            std::ofstream header(lastArg.c_str());
            if (!header.is_open()) {
                throw std::logic_error("Failed to open header file");
            }

            size_t numGraphs = (argc - 2) / 2;
            generateHeader(std::vector<char *>(argv + 1, argv + numGraphs + 1),
                           std::vector<char *>(argv + numGraphs + 1, argv + argc - 1),
                           header);
        } else {
            InferenceEngine::Core ie;
            ie.RegisterPlugin(argv[2], "cpu_reference");

            auto network = ie.ReadNetwork(argv[1]);
            auto execNetwork = ie.LoadNetwork(network, "cpu_reference");
            auto execGraph = execNetwork.GetExecGraphInfo();
            execGraph.serialize(lastArg);
        }
    } catch (const std::exception & ex) {
        std::cerr << ex.what() << std::endl;
        return EXIT_FAILURE;
    }

    return EXIT_SUCCESS;
}
