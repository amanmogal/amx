// Copyright (C) 2018-2020 Intel Corporation
// SPDX-License-Identifier: Apache-2.0
//

#include <string>
#include <iostream>
#include <fstream>
#include <cstdlib>
#include <vector>

#include <file_utils.h>
#include <xml_parse_utils.h>
#include <ie_core.hpp>

namespace {

void processGraph(const char * execGraph, std::ostream & header) {
    auto parse_result = ParseXml(execGraph);
    if (!parse_result.error_msg.empty()) {
        throw std::logic_error(parse_result.error_msg);
    }
    auto xmlDoc = std::move(parse_result.xml);
    pugi::xml_node root = xmlDoc->document_element();

    header << "//\n";
    header << "// Macro definitions for " << XMLParseUtils::GetStrAttr(root, "name", "") << std::endl;
    header << "//\n\n";

    auto printDefinitions = [&](const std::string & layer,
                                const std::vector<std::string> & defines) {
        header << "// " << layer << std::endl;
        for (auto && define : defines) {
            header << "#ifndef " << define << std::endl;
            header << "#define " << define << " 1" << std::endl;
            header << "#endif" << std::endl;
        }
        header << std::endl;
    };

    for (auto node = root.child("layers").child("layer"); !node.empty();
              node = node.next_sibling("layer")) {
        std::string layerName = XMLParseUtils::GetStrAttr(node, "id") + ":" +
                                XMLParseUtils::GetStrAttr(node, "name");
        std::string type = "Gen_" + XMLParseUtils::GetStrAttr(node, "type");

        auto dataNode = node.child("data");
        std::string primitiveType = XMLParseUtils::GetStrAttr(dataNode, "primitiveType");

        printDefinitions(layerName, {
            type,
            type + "_" + primitiveType
        });
    }
}

void generateHeader(const std::vector<char *> & execGraphs, std::ostream & header) {
    // generate common macro
    header << "// autogenerated: do not touch\n\n";
    header << "#ifdef GraphGen\n";
    header << "#error \"GraphGen already defined\"\n";
    header << "#else\n";
    header << "#define GraphGen(impl) impl\n";
    header << "#endif \n\n";

    for (auto && execGraph : execGraphs) {
        processGraph(execGraph, header);
    }
}

}  // namespace

int main(int argc, char *argv[]) {
    try {
        std::string lastArg = argv[argc - 1];
        bool genHeaderMode = FileUtils::fileExt(lastArg) == "hpp";

        if (genHeaderMode) {
            std::ofstream header(lastArg.c_str());
            if (!header.is_open()) {
                throw std::logic_error("Failed to open header file");
            }

            generateHeader(std::vector<char *>(argv + 1, argv + argc - 1), header);
        } else {
            InferenceEngine::Core ie;
            auto network = ie.ReadNetwork(argv[1]);
            auto execNetwork = ie.LoadNetwork(network, "CPU_FULL");
            auto execGraph = execNetwork.GetExecGraphInfo();
            execGraph.serialize(lastArg);
        }
    } catch (const std::exception & ex) {
        std::cerr << ex.what() << std::endl;
        return EXIT_FAILURE;
    }

    return EXIT_SUCCESS;
}
